Documentation
info
This guide is a work in progress and does not reflect the full functionality or the final/current state of the Baileys project.
Baileys is a WhatsApp Web API automation TypeScript library (Node supported, web/extension support planned). This project doesn't control WhatsApp using an automated browser, but instead uses WhatsApp Web's WebSocket-based protocol to interact with WhatsApp servers.
note
If you don't use TypeScript or JavaScript, it is recommended to learn them before using this library.
Baileys does not use the WhatsApp Business API (WABA). Rather it connects to a personal or a business (mobile app) account using the Linked Devices feature.
Yes, this means that this project is in no way affiliated with or endorsed by WhatsApp. Use at your own discretion. Do not spam people with this. We discourage any stalkerware, bulk or automated messaging usage.
Installation
Adding Baileys to your project is as simple as:
•	npm
•	Yarn
•	pnpm
npm install baileys

info
As of now, Baileys requires Node 17+ to function. It is planned to abstract the project away from Node in a future releasae.
Since NPM/Yarn releases are on a semi-monthly basis, you can use the GitHub branch directly
Synopsis
The main export of the Baileys library (and the default one) is the makeWASocket function.
This export returns an object full of socket-related functions. You can use these to interact with WhatsApp.
The socket is also an extension of an EventEmitter. You can listen to the events it emits to collect and store data. Baileys is asynchronous and event-based.
The socket authenticates with WhatsApp Web using the "Auth state", that you provide in the config. For this guide, we'll be using the useMultiFileAuthState to create this auth state.
warning
The auth state should be implemented from scratch, taking the built-in useMultiFileAuthState function as an inspiration. DO NOT rely on it in prod! It is very inefficient and is purely for demo purposes.
Next, we'll be learning in specific about the Socket type, and how to use its functions!
Configuration
The first step into getting anywhere with Baileys is configuring the socket.
Baileys is very open by default and allows you to configure various options.
All configuration is passed through the makeWASocket function. The config presents itself as the type UserFacingSocketConfig.
You can take a look at the type, I won't bore you here. The only required properties here strictly speaking are auth, logger, and getMessage.
logger
Baileys uses the pino library to log by default, but after a recent change (#1153), as long as you define a similar type, you'll be OK. As for pino, you can stream the logs into a file or even consume them as a realtime data stream.
auth
You should always implement your own auth state. Whether you decide a SQL, no-SQL or Redis auth state fits you best, that depends on your needs.
As of now, there are no actively maintained 3rd-party auth states, but if there are any I'll add them here.
getMessage
•	It is important to note the getMessage function. This functionality is needed for resending missing messages or decrypting poll votes.
•	This should be implemented by making a call to your database or wherever the message is stored, using the message key as an index.
With that in mind, your configuration should look like this:
import makeWASocket from 'baileys'
import P from 'pino'
const sock = makeWASocket({
  auth: any, // auth state of your choosing,
  logger: P() // you can configure this as much as you want, even including streaming the logs to a ReadableStream for upload or saving to a file
})

browser
The only consideration is when logging in using pairing code. In that case you should only set a valid/logical browser config (e.g. Browsers.macOS("Google Chrome")), otherwise the pair will fail. Once you are fully paired, you can switch the browser config back to normal.
version
It is recommended to leave the version settings to their default options. In future releases, the WhatsApp version will be actively locked to the library to insure maximum compatibility, under the ProtoCocktail project.
Also, It is not recommended to set the latest version on your socket every time you connect (e.g. using fetchLatestWaWebVersion), as you may face incompabitility. If you want to set a custom version, make sure your protobufs are up to date and that you are a few versions behind.
syncFullHistory
Baileys emulates a web browser by default (in the connection headers). If you want to emulate a desktop to get full chat history events, use the syncFullHistory option.
Also, your browser string should be a desktop:
browser: Browsers.macOS("Desktop") // can be Windows/Ubuntu instead of macOS

markOnlineOnConnect
By default, Baileys sets your presence as online on connect. This will stop sending notifications to your phone. To counter this, you can set the markOnlineOnConnect option to false.
If you are still facing missing notifications, check the Presence [reference missing] page.
cachedGroupMetadata
When sending messages to a group, the sendMessage function will try to get the group participant list (to encrypt the message to each participant).
This is a problem and causes a ratelimit and potential bans from WhatsApp. To counter this, you should provide the socket with a cachedGroupMetadata cache.
const groupCache = new NodeCache({ /* ... */ })

const sock = makeWASocket({
    cachedGroupMetadata: async (jid) => groupCache.get(jid)
})
Connecting
After configuring the socket, comes connecting to WhatsApp servers.
There are 2 methods to pair your device, the QR code pairing method and the phone number/pairing code method.
After creating the socket, it will automatically connect and then start sending events.
The main event we should be concerned of at the moment is the connection.update event. When listening onto this event, you receive various connection states and a QR string.
For example, utilising the qrcode package:
// you can use this package to export a base64 image or a canvas element.
import QRCode from 'qrcode'

sock.ev.on('connection.update', async (update) => {
  const {connection, lastDisconnect, qr } = update
  // on a qr event, the connection and lastDisconnect fields will be empty

  // In prod, send this string to your frontend then generate the QR there
  if (qr) {
    // as an example, this prints the qr code to the terminal
    console.log(await QRCode.toString(qr, {type:'terminal'}))
  }
})

After scanning the code, WhatsApp will forcibly disconnect you, forcing a reconnect such that we can present the authentication credentials. Don't worry, this is not an error. You must handle this as well in the connnection.update event:
import {DisconnectReason} from 'baileys'
sock.ev.on('connection.update', (update) => {
  const {connection, lastDisconnect} = update
  if (connection === 'close' && (lastDisconnect?.error as Boom)?.output?.statusCode === DisconnectReason.restartRequired) {
    // create a new socket, this socket is now useless
  }
})

Auth state
In order to reconnect successfully, we must pass a way for Baileys to persist credentials and encryption keys.
warning
DONT EVER USE THE useMultiFileAuthState IN PROD. YOU HAVE BEEN WARNED. This function consumes a lot of IO. Only use its implementation as a guide. As I said earlier here
After obtaining the relevant creds from WhatsApp, Baileys will drop the creds.update event to make sure you save them. This event triggers every time creds are updated.
// DO NOT USE IN PROD!!!!
const { state, saveCreds } = await useMultiFileAuthState("auth_info_baileys");
// will use the given state to connect
// so if valid credentials are available -- it'll connect without QR
const sock = makeWASocket({ auth: state });
// this will be called as soon as the credentials are updated
sock.ev.on("creds.update", saveCreds);

Pairing Code login
When you want to request a pairing code, you should wait at least until the connecting/QR event like above. You shouldn't worry about the QR events, they just exist there.
The phone number MUST be in E.164 format without a plus sign (+1 (234) 567-8901 -> 12345678901).
sock.ev.on('connection.update', async (update) => {
  const {connection, lastDisconnect, qr } = update
  if (connection == "connecting" || !!qr) { // your choice
    const code = await sock.requestPairingCode(phoneNumber)
    // send the pairing code somewhere
  }
})

Great! You should be connected now.
History Sync
After connecting successfully, the socket will try to download and process old chats, contacts and messages.
This data is delivered to you via the messaging-history.set event. Here's an example on how to handle this data:
sock.ev.on('messaging-history.set', ({
	chats: newChats,
	contacts: newContacts,
	messages: newMessages,
	syncType
}) => {
  // handle the chats, contacts and messages
})

You should store this data in your database and use it however you want. However, you should keep a record of messages so you can provide those messages to the getMessage function in the socket config.
Disabling History Sync
You can choose to disable or receive no history sync messages by setting the shouldSyncHistoryMessage option to () => false.
On-Demand History Sync
It is possible ask the main device for history data beyond the initial sync. This is done using the sock.fetchMessageHistory function.
Receiving Updates
After getting the initial "history" messages, let's get real-time messages and updates.
Baileys exposes these updates via the event emitter as well.
Message events
messages.upsert
This event provides you with messages that you get either on offline sync or in real time.
The type of upsert is provided as either notify or append. Notify messages are usually the new messages, meanwhile append messages are everything else.
This event provides an array of proto.IMessages, so make sure to handle every item in the array.
Look into the Handling Messages page to handle the IMessage properly.
As an example:
sock.ev.on('messages.upsert', ({type, messages}) => {
  if (type == "notify") { // new messages
    for (const message of messages) {
      // messages is an array, do not just handle the first message, you will miss messages
    }
  } else { // old already seen / handled messages
    // handle them however you want to
  }
})

messages.update
Whether the message got edited, deleted or something else happened (change of receipt /ack state), a message update will be fired.
messages.delete
This event exists to declare the deletion of messages.
messages.reaction
Whether a reaction was added or removed to a message
message-receipt.update
This runs in groups and other contexts, where it tells you updates on who received/viewed/played messages.
Chat events
chats.upsert
This is triggered whenever a new chat is opened with you.
chats.update
This is triggered on every message (to change the unread count), and to put the latest message / latest message timestamp in the chat object.
chats.delete
This is triggered when the chat is deleted only.
blocklist.set
blocklist.update
Self-explanatory
call
Universal event for call data (accept/decline/offer/timeout etc.)
Contact events
contacts.upsert
Upon the addition of a new contact to the main device's address book
contacts.update
Upon the change of a saved contact's details
Group events
groups.upsert
When you are joined in a new group.
groups.update
When metadata about the group changes.
group-participants.update
When the participants of group change or their ranks change
Handling Messages
Messages, from a history sync or from a messages.upsert event, come in the form of proto.IWebMessageInfo. This is the protobuf that WhatsApp Web stores its messages in.
The message data specifically is in the format proto.IMessage. You can send messages in this format using the sock.relayMessage function.
Understanding the proto.IWebMessageInfo format
Explain the key, and other fields properly here.
That being said, let's look at some common message types:
Text Messages
Text based messages come in the form of proto.IMessage.conversation and proto.IMessage.extendedTextMessage. If the message comes in with reply data or attached metadata (link preview, group invite), then it is usually extendedTextMessage. Status updates are also only extendedTextMessage as it contains the fields for the color/font of the text-based status updates.
Handling this should be as easy as extracting the text from the
Media Messages
Media messages come in the following protobuf messages: proto.IMessage.audioMessage, proto.IMessage.documentMessage, proto.IMessage.imageMessage, video, sticker .. so on Handle missing media : -> sock.updateMediaMessage

